GETMEM16:
push eax
push ebx
push ecx
push edx
push esi
push edi
mov ax,es
push ax
mov ax,ds
push ax

mov ax,cs
mov es,ax
mov ds,ax

xor ebx,ebx
mov di,GETMEMBUFF ;es:di = ASRD
.loop:
mov eax,0E820h
mov ecx,20
;edx = 'SMAP'
mov edx,0534D4150h
int 15h
;if (CF!=0)
jc .fail
inc dword [GETMEMNUM]
;forward 20bytes
add di,20
cmp ebx,0
jne .loop
jmp .end
.fail:
mov dword [GETMEMNUM],0
.end:

pop ax
mov ds,ax
pop ax
mov es,ax
pop edi
pop esi
pop edx
pop ecx
pop ebx
pop eax
ret

DISPMEM16:
;must include io16.lib
push eax
push esi
push edi
push ecx
push edx
push ebp
mov ax,ds
push ax
mov ax,es
push ax

mov ax,cs
mov ds,ax
mov es,ax

xor eax,eax
mov eax,RAMTABLE16
push eax
call near DISPSTR16
pop eax

call DISPRETURN16

xor ebp,ebp
mov esi,GETMEMBUFF
mov ecx,[ds:GETMEMNUM]
mov edx,5
	.loop1:
	mov eax,dword [ds:esi]
	push eax
	call near DISPINTEAX16
	pop eax
	call near DISPSPACE16
	inc ebp
	dec edx
	add esi,4
	cmp ebp,5
	jne .noinfo
		xor ebp,ebp
		cmp eax,1
		je .ava
		mov eax,RAMRESERVED
		push eax
		call near DISPSTR16
		pop eax
		jmp .noinfo
	.ava:
		mov eax,RAMAVAILABLE
		push eax
		call near DISPSTR16
		pop eax
.noinfo:
	cmp edx,0
	jne .loop1
	cmp dword [ds:esi-4],1
	jne .end2
	mov eax,dword [ds:esi-20]
	add eax,dword [ds:esi-12]
	cmp eax,[ds:DISPMEMTOTAL]
	jb .end2
	mov [ds:DISPMEMTOTAL],eax
.end2:
	call near DISPRETURN16
	dec ecx
	mov edx,5
	cmp ecx,0
	je .end1
	jmp .loop1
.end1:
	call near DISPRETURN16
	mov eax,RAMSIZE
	push eax
	call near DISPSTR16
	pop eax
	push dword [ds:DISPMEMTOTAL]
	call near DISPINTEAX16
	pop eax
pop ax
mov es,ax
pop ax
mov ds,ax
pop ebp
pop edx
pop ecx
pop edi
pop esi
pop eax
ret

DISPINTEAX16:
;Entrance: push eax
push ebp
mov ebp,esp
push eax

mov eax,dword [ss:ebp+6]
shr eax,24
mov ah,0Fh
push ax
call near DISPINTAL16
pop ax

mov eax,dword [ss:ebp+6]
shr eax,16
mov ah,0Fh
push ax
call near DISPINTAL16
pop ax

mov eax,dword [ss:ebp+6]
shr eax,8
mov ah,0Fh
push ax
call near DISPINTAL16
pop ax

mov eax,dword [ss:ebp+6]
mov ah,0Fh
push ax
call near DISPINTAL16
pop ax

pop eax
pop ebp
ret

DISPSTR16:
;Entrance: push offset
;ds:offset = String
push ebp
mov ebp,esp
push esi
push edi
push eax
push ebx
push gs

mov ax,0b800h
mov gs,ax
mov esi,dword [ss:ebp+6]
mov edi,dword [ds:GRAPHPOS]
.loop1:
mov al,byte [ds:esi]
cmp al,0
je .end
cmp al,0Ah
jne .loop2
;let edi point to the next row
;edi/(80*2) - every row:80 chars, each char takes 2 bytes.
push eax
mov eax,edi
mov bl,160
div bl
;only keep the low 8 of eax(al,aka quotion)
and eax, 0FFh
inc eax
;calculate the edi now
mov bl,160
mul bl
mov edi,eax
pop eax
inc esi
jmp .loop1
.loop2:
mov ah,0Fh
mov word [gs:edi],ax
add edi,2
inc esi
jmp .loop1
.end:
mov dword [ds:GRAPHPOS],edi

pop gs
pop ebx
pop eax
pop edi
pop esi
pop ebp
ret 

DISPINTAL16:
;Entrance: push ax ,AH=ATTR, AL=Char
push ebp
mov ebp,esp
push eax
push gs
push ecx
push edi
push ebx
push ds

mov ax,cs
mov ds,ax
mov edi,dword [ds:GRAPHPOS]
mov ax,0b800h
mov gs,ax
xor eax,eax
mov ax, word [ss:ebp+6]
mov bx,ax
;keep high 4 bits of al
and al,0F0H
mov cl,4
shr al,cl
call near CHANGEAL
mov word [gs:edi],ax
add edi,2
mov dword [ds:GRAPHPOS],edi
;keep low 4 bits of al
mov ax,bx
and al,0Fh
call near CHANGEAL
mov ah,bh
mov word [gs:edi],ax
add edi,2
mov dword [ds:GRAPHPOS],edi

pop ds
pop ebx
pop edi
pop ecx
pop gs
pop eax
pop ebp
ret

CHANGEAL:
;Entrance:void
cmp al,09h
jna .l2
add al,37h
jmp .end
.l2:
add al,30h
.end:
ret

DISPRETURN16:
push eax
push ds

mov ax,cs
mov ds,ax
mov eax,IO16_RETURN
push eax
call near DISPSTR16
pop eax

pop ds
pop eax
ret

DISPSPACE16:
push eax
push ds

mov ax,cs
mov ds,ax
mov eax,IO16_SPACE
push eax
call near DISPSTR16
pop eax

pop ds
pop eax
ret



